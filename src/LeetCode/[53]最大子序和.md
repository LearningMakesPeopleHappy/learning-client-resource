# 53. 最大子序和

## 题目

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> **测试**
>
> [-2,1,-3,4,-1,2,1,-5,4] - 6

## 思路

### 枚举法



#### 时间复杂度



### 空间复杂度



#### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    const len = nums.length;

    let max_val = Number.MIN_SAFE_INTEGER;

    for (let i = 0; i < len; i++) {
        let sum = nums[i];
        if (sum > max_val) {
            max_val = sum;
        }

        let end = i + 1;
        for (; end < len; end++) {
            sum += nums[end];
            if (sum > max_val) {
                max_val = sum;
            }
        }
    }

    return max_val;
};
```



### 贪心算法

1. 取第一项item1，因为没有前面的项，所以将item1设置为当前最大值max以及当前的段内最大值current。
2. 取第二项item2，与前一段的最大值current相加，和item2做对比，得出当前段内的最大值，即item1 + item2与item2做对比，如果item1 + item2大于item2，证明item1大于0，所以对于item1和item2组成的数组来说，排除掉item1，最大的子串为[item1, item2]。如果item1 + item2小于item2，证明item1小于0，就扔掉item1，也就是说，在元素有负数的时候，负数元素在最大和子串中必不可能为开头和结尾。让current等于这个分段的最大值。
3. 将前面所有段的最大值item1和当前子段的最大值current做对比，将大的值赋值给max。
4. ......

将前段最大值与当前数求和，然后和当前数进行比较，而不将前前项与之比较的原因是，如果前前项最大，前项被抛弃，子串就断开了。就好比[a, b, c]这个子串，比较的是a + b + c的值与c的大小，最后留下的值是c，如果比较a和c留下a，那么b和c都会被抛弃。后面再接d的话，a与d是无法组成子串的。

#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let current = 0;
    let max = Number.MIN_SAFE_INTEGER;

    for (const item of nums) {
        current = Math.max(item, current + item);
        max = Math.max(max, current);
    }

    return max;
};
```





## 进阶

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

