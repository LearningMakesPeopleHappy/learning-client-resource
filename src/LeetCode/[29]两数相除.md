# 29.两数相除

## 题目

给定两个整数，被除数`dividend`和除数`divisor`。将两数相除，要求不使用乘法、除法和`mod`运算符。

返回被除数`dividend`除以除数`divisor`得到的商。

整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8`以及`truncate(-2.7335) = -2`



> **测试**
>
> 输入: dividend = 10, divisor = 3
> 输出: 3
> 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
>
> 输入: dividend = 7, divisor = -3
> 输出: -2
> 解释: 7/-3 = truncate(-2.33333..) = -2



**提示：**

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。

## 思路

### 暴力累加法（步长为2）



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const max = 2147483647;
    const min = -2147483648;
    if (dividend === 0) {
        return 0;
    }

    if (divisor === 1) {
        return dividend < min ? max : (dividend > max ? max : dividend);
    }

    if (dividend === divisor) {
        return 1;
    }

    let positive = true;
    if (dividend < 0) {
        positive = !positive;
        dividend = -dividend;
    }

    if (divisor < 0) {
        positive = !positive;
        divisor = -divisor;
    }

    if (dividend < divisor) {
        return 0;
    }

    let result = 1;
    let sum = divisor + divisor + divisor;
    while (sum <= dividend) {
        result += 2;
        sum += divisor + divisor;
    }

    if (sum - divisor <= dividend) {
        result++;
    }

    result *= (positive ? 1 : -1);

    return result < min ? max : (result > max ? max : result);
};
```



### 按位累加法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const max = 2147483647;
    const min = -2147483648;
    if (dividend === 0) {
        return 0;
    }

    if (divisor === 1) {
        return dividend < min ? max : (dividend > max ? max : dividend);
    }

    if (divisor === -1) {
        dividend = -dividend;
        return dividend < min ? max : (dividend > max ? max : dividend);
    }

    if (dividend === divisor) {
        return 1;
    }

    if (dividend === -divisor) {
        return -1;
    }

    let positive = true;
    if (dividend < 0) {
        positive = !positive;
        dividend = -dividend;
    }

    if (divisor < 0) {
        positive = !positive;
        divisor = -divisor;
    }

    if (dividend < divisor) {
        return 0;
    }

    let dividend_str = dividend.toString();
    let divisor_str = divisor.toString();

    let result = [];
    let t_y = '';

    while (dividend_str.length > 0) {
        let newStr = t_y + dividend_str;
        let {
            s,
            y,
        } = deal(parseInt(newStr.slice(0, divisor_str.length + 1)), divisor);
        result.push(s);
        t_y = y === 0 ? '' : y.toString();
        dividend_str = newStr.slice(divisor_str.length + 1);
    }

    result = parseInt(result.join(''));
    result *= (positive ? 1 : -1);

    return result < min ? max : (result > max ? max : result);
};

let deal = function (dividend, divisor) {
    let res = 0;
    let sum = divisor;
    while (sum <= dividend) {
        res++;
        sum += divisor;
    }

    return {
        s: res,
        y: dividend - sum + divisor,
    };
}
```



### 递归逼近法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
    const max = 2147483647;
    const min = -2147483648;
    if (dividend === 0) {
        return 0;
    }

    if (divisor === 1) {
        return dividend < min ? max : (dividend > max ? max : dividend);
    }

    if (divisor === -1) {
        dividend = -dividend;
        return dividend < min ? max : (dividend > max ? max : dividend);
    }

    if (dividend === divisor) {
        return 1;
    }

    if (dividend === -divisor) {
        return -1;
    }

    let positive = true;
    if (dividend < 0) {
        positive = !positive;
        dividend = -dividend;
    }

    if (divisor < 0) {
        positive = !positive;
        divisor = -divisor;
    }

    if (dividend < divisor) {
        return 0;
    }

    let result = deal(dividend, divisor)

    result *= (positive ? 1 : -1);

    return result < min ? max : (result > max ? max : result);
};

let deal = function(dividend, divisor) {
    if (dividend < divisor) {
        return 0;
    }

    let result = 1; // 2
    let current = divisor; // 6
    let sum = divisor; // 6
    while (sum + current <= dividend) {
        sum += current;
        current += current;
        result += result;
    }

    let y = dividend - sum;

    return result + deal(y, divisor);
}

```

