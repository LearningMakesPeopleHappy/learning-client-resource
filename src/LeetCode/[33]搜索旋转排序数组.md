# 33. 搜索旋转排序数组

## 题目

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

> **测试**
>
> 输入: nums = [4,5,6,7,0,1,2], target = 0
> 输出: 4
>
> 输入: nums = [4,5,6,7,0,1,2], target = 3
> 输出: -1

## 思路

### 二分法



#### 时间复杂度



#### 空间复杂度



### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let len = nums.length;
    if (len < 4) {
        switch (target) {
            case nums[0]:
                return 0;
            case nums[1]:
                return 1;
            case nums[2]:
                return 2;
            default:
                return -1;
        }
    }

    let center = Math.floor(len / 2) - 1;

    let start = nums[0];
    let center_left = nums[center];
    let center_right = nums[center + 1];
    let end = nums[len - 1];
    if (start < center_left) { // 前半段为递增
        if (start > target || target > center_left) {
            // 看后半段
            if (center_right < end) { // 后半段为递增
                let tempIndex = simplesearch(nums.slice(center + 1), target);
                return tempIndex < 0 ? -1 : (center + 1 + tempIndex);
            } else { // 后半段旋转
                let tempIndex = search(nums.slice(center + 1), target);
                return tempIndex < 0 ? -1 : (center + 1 + tempIndex);
            }
        } else {
            // 看前半段
            return simplesearch(nums.slice(0, center + 1), target);
        }
    } else { // 前半段旋转
        if (end < target || center_right > target) {
            // 看前半段
            return search(nums.slice(0, center + 1), target);
        } else {
            // 看后半段
            let tempIndex = simplesearch(nums.slice(center + 1), target);
            return tempIndex < 0 ? -1 : (center + 1 + tempIndex);
        }
    }
};

let simplesearch = function(nums, target) {
    let len = nums.length;
    if (len === 0) {
        return -1;
    } else if (len === 1) {
        return nums[0] === target ? 0 : -1;
    }

    let center = Math.floor(len / 2) - 1;

    let start = nums[0];
    let center_left = nums[center];
    let center_right = nums[center + 1];
    let end = nums[len - 1];

    if (target < start || target > end) {
        return -1;
    } else if (target <= center_left) {
        return simplesearch(nums.slice(0, center + 1), target);
    } else {
        let tempIndex = simplesearch(nums.slice(center + 1, len), target);
        return tempIndex < 0 ? -1 : center + 1 + tempIndex;
    }
}
```



### 双指针二分法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        let middle = Math.floor((right - left) / 2) + left;

        let left_val = nums[left];
        if (left_val === target) return left;

        let middle_val = nums[middle];
        if (middle_val === target) return middle;

        let right_val = nums[right];
        if (right_val === target) return right;

        if (left_val < middle_val) { // 前半段为递增
            if (left_val < target && target < middle_val) { // 查询前半段
                left++;
                right = middle - 1;
            } else { // 查询后半段
                left = middle + 1;
                right--;
            }
        } else { // 前半段有旋转点
            if (middle_val < target && target < right_val) { // 查询后半段
                left = middle + 1;
                right--;
            } else { // 查询前半段
                left++;
                right = middle - 1;
            }
        }
    }

    return -1;
};
```

