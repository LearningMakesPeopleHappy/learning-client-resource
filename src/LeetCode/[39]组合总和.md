# 39. 组合总和

## 题目

给定一个无重复元素的数组`candidates`和一个目标数`target`，找出`candidates`中所有可以使数字和为`target`的组合。

`candidates`中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。 

> **测试**
>
> 输入: candidates = [2,3,6,7], target = 7,
> 所求解集为:
> [
>   [7],
>   [2,2,3]
> ]
>
> 输入: candidates = [2,3,5], target = 8,
> 所求解集为:
> [
>   [2,2,2,2],
>   [2,3,3],
>   [3,5]
> ]

## 思路

### Hash列表比较法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    const len = candidates.length;

    candidates.sort((a, b) => a - b);

    let start = 0;

    let wait = new Map();

    let result = [];
    while (start < len) {
        let current = candidates[start];
        if (current > target) {
            break;
        }

        if (current === target) {
            result.push([target]);
            break;
        }
        
        for (let key of wait.keys()) {
            if (key - current < 0) {
                wait.delete(key);
            }
        }

        let l_map;

        let count = 0;
        while ((count + 1) * current <= target) {
            count++;

            let c_map = (l_map ? l_map : wait);
            let n_map = new Map();

            if (!l_map) {
                n_map.set(target - current, [[current]]);
            }

            for (let i_key of c_map.keys()) {
                let n_key = i_key - current;
                if (n_key === 0) {
                    c_map.get(i_key).forEach((val) => {
                        val.push(current);
                        result.push(val);
                    });
                } else {
                    let n_list = [];
                    let o_list = c_map.get(i_key);
                    if (n_key >= current) {
                        o_list.forEach((val) => {
                            n_list.push([...val, current]);
                        });

                        n_map.set(n_key, n_list);
                    }
                }

                if (l_map) {
                    let l_key_list = wait.get(i_key);
                    if (l_key_list) {
                        wait.set(i_key, l_key_list.concat(c_map.get(i_key)));
                    } else {
                        wait.set(i_key, c_map.get(i_key));
                    }
                }
            }

            l_map = n_map;
        }

        if (l_map) {
            for (let l_key of l_map.keys()) {
                let l_key_list = wait.get(l_key);
                if (l_key_list) {
                    wait.set(l_key, l_key_list.concat(l_map.get(l_key)));
                } else {
                    wait.set(l_key, l_map.get(l_key));
                }
            }
        }

        start++;
    }

    return result;
};
```



### 递归剪枝法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    const len = candidates.length;
    candidates.sort((a, b) => a - b);
    let f = 0;
    let result = [];
    while (f < len) {
        let current = candidates[f];
        if (current > target) {
            break;
        }

        if (current === target) {
            result.push([current]);
            break;
        }

        combinationSum(candidates.slice(f), target - current).forEach((val) => {
            val.push(current);
            result.push(val);
        });

        f++;
    }

    return result;
};
```

