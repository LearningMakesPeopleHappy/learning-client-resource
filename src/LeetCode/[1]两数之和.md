# 1. 两数之和

## 题目

给定一个整数数组`nums`和一个目标值`target`，请你在该数组中找出和为目标值的那`两个`整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

> **测试**
>
> [-1,13,2,100,99,98,88,80,3,77,79,101,5,66,7,64,32,14,16,20,31,11,15] - 9

## 思路

### 暴力循环

通过双循环的方式暴力找到对应的两个数。

#### 时间复杂度

> 设查询数组中共`n`个元素，一个元素用时`T0`，两数相加求和用时`T1`

(n - 1) * T0 + (n - 1) * (n - 1) * T0 + (n - 1) * (n - 1) * T1
= (n^2 - n) * T0 + (n^2 - 2n + 1) * T1
= O(n^2)

#### 空间复杂度

O(1)

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let i = nums.length - 1;
    while (i > 0) {
        for (let j = i - 1; j >= 0; j--) {
            if (nums[i] + nums[j] === target) {
                return [j, i];
            }
        }

        i--;
    }
};
```

### 映射表匹配

消耗一定的空间换来时间上的最优解。

声明一个Map，将需要的数（target - current）放入其中，与之后的元素比较。

#### 时间复杂度

O(n)

#### 空间复杂度

O(n)

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let mapping = new Map();
    for (let i = nums.length - 1; i >= 0; i--) {
        let current = nums[i];
        let c = target - current;
        let n = mapping.get(current);
        if (n !== undefined) {
            return [i, n];
        }

        mapping.set(c, i);
    }
};
```

