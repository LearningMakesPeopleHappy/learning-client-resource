# 6. Z字形变换

## 题目

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"LEETCODEISHIRING"` 行数为 3 时，排列如下：

```
L   C   I   R
E T O E S I I G
E   D   H   N
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"LCIRETOESIIGEDHN"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

> **测试**
>
> 输入: s = "LEETCODEISHIRING", numRows = 3
> 输出: "LCIRETOESIIGEDHN"
>
> 输入: s = "LEETCODEISHIRING", numRows = 4
> 输出: "LDREOEIIECIHNTSG"

## 思路



### 正向排列法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows === 1) return s;

    const len = s.length;

    const list = [];
    for (let line = 0; line < numRows; line++) {
        list.push([]);
    }

    const members_num = (numRows - 1) * 2;

    const group_num = Math.ceil(len / members_num);

    for (let i = 1; i <= len; i++) {
        let index = i % members_num;
        if (index === 0) {
            index = members_num;
        }

        if (index <= numRows) {
            list[index - 1].push(s[i - 1]);
        } else {
            list[numRows - (index - numRows) - 1].push(s[i - 1]);
        }
    }

    let result = '';
    for (let lineList of list) {
        result += lineList.join('');
    }

    return result;
};
```



### 规律法



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows === 1) return s;

    const len = s.length;

    const members_num = (numRows - 1) * 2;

    const group_num = Math.ceil(len / members_num);

    let last_group_members_count = len % members_num;
    if (last_group_members_count === 0) {
        last_group_members_count = members_num;
    }

    let result = '';
    let line = 0;
    while (line < numRows) {
        let index = 0;
        if (line === 0) { // 第一行
            while (index < group_num) {
                result += s[index * members_num];
                index++;
            }
        } else if (line === numRows - 1) { // 最后一行
            const line_memebers_num = group_num - (last_group_members_count < numRows ? 1 : 0);
            while (index < line_memebers_num) {
                result += s[numRows - 1 + index * members_num];
                index++;
            }
        } else { // 中间行
            let line_memebers_num = group_num * 2;
            if ((members_num - last_group_members_count) >= line) {
                if (last_group_members_count <= line) {
                    line_memebers_num -= 2;
                } else {
                    line_memebers_num--;
                }
            }

            while (index < line_memebers_num) {
                result += s[(index % 2 ? (members_num - line * 2) : 0) + line + members_num * Math.floor(index / 2)];
                index++;
            }
        }

        line++;
    }

    return result;
};
```

