# 18. 四数之和

## 题目

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

> **测试**
>
> 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。
>
> 满足要求的四元组集合为：
> [
>   [-1,  0, 0, 1],
>   [-2, -1, 1, 2],
>   [-2,  0, 0, 2]
> ]

## 思路

### 类三数之和



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a, b) => a - b);
    const len = nums.length;

    const s_set = new Set();

    const result = [];

    let f_i = 0;
    while (f_i < len - 3) {
        const f_num = nums[f_i];
        if (f_num === nums[f_i - 1]) {
            f_i++;
            continue;
        }
        
        if(nums[f_i] + nums[f_i + 1] + nums[f_i + 2] + nums[f_i + 3] > target){
            break;
        }
        
        if(nums[f_i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target){
            f_i++;
            continue;
        }

        let s_i = f_i + 1;
        while (s_i < len - 2) {
            const s_num = nums[s_i];
            if (s_i > f_i + 1 && s_num === nums[s_i - 1]) {
                s_i++;
                continue;
            }

            const s_key = Math.min(f_num, s_num) + '' + Math.max(f_num, s_num);
            if (!s_set.has(s_key)) {
                s_set.add(s_key);

                let t_start = s_i + 1;
                let t_end = len - 1;
                while (t_start < t_end) {
                    const t_s_num = nums[t_start];
                    const t_e_num = nums[t_end];

                    const c_target = f_num + s_num + t_s_num +t_e_num;
                    if (c_target === target) {
                        result.push([f_num, s_num, t_s_num, t_e_num]);

                        do {
                            t_start++;
                        } while(nums[t_start] === t_s_num);

                        do {
                            t_end--;
                        } while(nums[t_end] === t_e_num);
                    } else if (c_target < target) {
                        do {
                            t_start++;
                        } while(nums[t_start] === t_s_num);
                    } else {
                        do {
                            t_end--;
                        } while(nums[t_end] === t_e_num);
                    }
                }
            }

            s_i++;
        }

        f_i++;
    }

    return result;
};
```

