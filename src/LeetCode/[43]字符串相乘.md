# 43. 字符串相乘

## 题目

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

> 输入: num1 = "2", num2 = "3"
> 输出: "6"

**示例 2:**

> 输入: num1 = "123", num2 = "456"
> 输出: "56088"

**说明：**

- num1 和 num2 的长度小于110。
- num1 和 num2 只包含数字 0-9。
- num1 和 num2 均不以零开头，除非是数字 0 本身。
- 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。

## 思路

### 按位累加



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
    if (num1 === '0' || num2 === '0') {
        return '0';
    }

    let min;
    let max;
    if (num1.length < num2.length) {
        min = num1;
        max = num2.split('');
    } else {
        min = num2;
        max = num1.split('');
    }

    const len = min.length;
    let index = 0;

    let list = [];
    while (index < len) {
        let count = parseInt(min[len - 1 - index]);

        if (count === 0 && list.length - 1 - index < 0) {
            list.unshift('0');
        }

        while (count > 0) {
            sum(list, max, index);
            count--;
        }

        index++;
    }

    return list.join('');
};

let sum = function(list, target, count) {
    let i = 0;
    const len = Math.max(list.length - count, target.length);
    let c = 0;
    while (i < len) {
        let target_val = target[target.length - 1 - i];
        let list_val = list[list.length - 1 - count - i];
        let temp_result = (target_val ? parseInt(target_val) : 0) + (list_val ? parseInt(list_val) : 0) + c;

        if (i + count + 1 > list.length) {
            list.unshift((temp_result%10).toString());
        } else {
            list[list.length - 1 - count - i] = (temp_result%10).toString();
        }
        
        c = Math.floor(temp_result/10);
        i++;
    }

    if (c) {
        list.unshift(c.toString());
    }
}
```



### 按位迭代

将两个数按照大小分为`min`和`max`。

我们知道最后的结果是`min`和`max`长度减一，即`min.length + max.length - 1`。

所以我们从结果的右侧（最小位）开始迭代，取`index = 0`。

根据下面的分析，我们可以得出一个规律：

```
// 最右侧为第0位，一个乘积和表示为(x, y)

        1     6     0
x             1     2
---------------------------
进位值 进位值 进位值
      (2,0) (1,0) (0,0)
(2,1) (1,1) (0,1)
---------------------------
  1     9     2     0



                    1     2     3     4
x                   5     6     7     8
-------------------------------------------
进位值 进位值 进位值 进位值 进位值 进位值
                  (3,0) (2,0) (1,0) (0,0)
            (3,1) (2,1) (1,1) (0,1)
      (3,2) (2,2) (1,2) (0,2)
(3,3) (2,3) (1,3) (0,3)
-------------------------------------------
  7     0     0     6     6     5     2
```

所以在`index`递增的时候分前后两种情况分别获取长数指针`start`和短数指针`end`。

以`160x12`为例：

`index`为`0`时，`start`和`end`均为`0`。

`index`为`1`时，`start`为`1`和`end`为`0`。

`index`为`2`时，`start`为`2`和`end`为`0`。

`index`为`3`时，`start`为`2`和`end`为`1`。

`start`递减，`end`递增（`end`最大取值为短数长度减一），迭代求当前位的和（别忘了加上进位值）。

余数为当前位数的值，商向下取整，进位。

最后如果有余数，则为新进位。



#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
    if (num1 === '0' || num2 === '0') {
        return '0';
    }

    let min;
    let max;
    if (num1.length < num2.length) {
        min = num1;
        max = num2;
    } else {
        min = num2;
        max = num1;
    }

    const min_len = min.length;
    const max_len = max.length;
    let index = 0;

    let wait = 0;

    let list = [];
    const result_len = max_len + min_len - 1;
    while (index < result_len) {
        let start;
        let end;

        if (index < max_len) {
            start = index;
            end = 0;
        } else {
            start = max_len - 1;
            end = index - max_len + 1;
        }

        let sum = wait;

        while (start >= 0 && end < min_len) {
            sum += max[max_len - 1 - start] * min[min_len - 1 - end];
            start--;
            end++;
        }

        list.unshift(sum % 10);
        wait = Math.floor(sum / 10);
        index++;
    }

    if (wait) {
        list.unshift(wait);
    }

    return list.join('');
};
```

