# 5. 最长回文子串

## 题目

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

> **测试**
>
> 输入: "babad"
> 输出: "bab"
>
> 输入: "cbbd"
> 输出: "bb"

## 思路

### 递归截取

> **注意**：会超时

#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if (s.length <= 1) {
        return s;
    }
    
    const len = Math.floor(s.length / 2);
    const f = s.slice(0, len);
    const a = s.slice(-len).split('').reverse().join('');
    if (a === f) {
        return s;
    }

    const fr = longestPalindrome(s.slice(0, s.length - 1));
    const ar = longestPalindrome(s.slice(1));
    return fr.length >= ar.length ? fr : ar;
};
```



### 遍历取中两边对比

从头遍历，取`i`位置的一个字符，设置一个数量`count`为`1`，对比`i - count`和`i + count`的字符是否相等，不想等就将`count - 1`配合`i`获得的索引值和当前的索引值对比，大的设置进去。如果`i + 1`位置的字符和`i`位置的字符相等，还需要对比`i - count`和`i + count + 1`位置的字符是否相等，如果不想等就将`count - 1`配合`i`获得的索引值和当前的索引值对比，大的设置进去。

即：

* 设置字符串长度`len`，结果的开始索引位置为`start`，结束索引位置为`end`。

* 设置索引`i`。
* 如果`i`小于字符串长度减去当前结果长度的一半（`len - Math.floor((end - start)/2)`），就进入`i`的循环。
    * 不用遍历`i`大于等于字符串长度减去当前结果长度的一半（`len - Math.floor((end - start)/2)`）的原因是因为，大于等于时，以`i`位置为中心的回文字符串长度永远不可能超过当前结果的长度。
* 设置`isS`为`true`。表示中心为一个字符。
* 如果`i + 1`的字符和`i`的字符相等，设置`isD`为`true`。表示中心为两个字符。
* 设置数量`count`为`1`。
* 如果`i - count`大于等于`0`，并且`i + count`小于`len`，就进入`count`的循环。
* 如果上面的`isD`为`true`，则比较`i - count`和`i + 1 + count`位置的字符是否相等，如果不想等并且当前结果的长度`end - start`小于`count * 2`，则将`i - count + 1`设置为`start`，将`i + 1 + count`设置为`end`，并且将`isD`置为`false`。
* 如果`isS`为`true`，则比较`i - count`和`i + count`位置的字符是否相等，如果不想等并且当前结果的长度`end - start`小于`count * 2 - 1`，则将`i - count + 1`设置为`start`，将`i + count`设置为`end`，并将`isS`置为`false`。
* 如果`isD`和`isS`都为`false`，那么就退出`count`的循环。
    * 如果`isD`和`isS`有任何一个为`true`，则将`count`累加。
* 如果没有进入`count`的循环或者退出了`count`的循环，并且`isD`为`true`，并且当前结果的长度`end - start`小于`count * 2`，则将`i - count + 1`设置为`start`，将`i + 1 + count`设置为`end`。
* 如果没有进入`count`的循环或者退出了`count`的循环，并且`isD`为`false`，并且当前结果的长度`end - start`小于`count * 2 - 1`，则将`i - count + 1`设置为`start`，将`i + count`设置为`end`。
* 如果没有进入`i`循环，或者退出了`i`循环，则通过`start`和`end`截取字符串得到最终的值。

#### 时间复杂度



#### 空间复杂度



#### 代码

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    const len = s.length;
        if (len < 1) return '';
        if (len === 1) return s;

        let start = 0;
        let end = 0;
        for (let i = 0; i < len - Math.floor((end - start) / 2); i++) {
            let count = 1;

            let isS = true;
            let isD = s[i] === s[i + 1];

            while (i - count >= 0 && i + count < len) {
                const f = s[i - count];

                if (isD) {
                    if (i + 1 + count < len) {
                        if (f !== s[i + 1 + count]) {
                            if (end - start < count * 2) {
                                start = i - count + 1;
                                end = i + 1 + count;
                            }

                            isD = false;
                        }
                    } else {
                        if (end - start < count * 2) {
                            start = i - count + 1;
                            end = i + 1 + count;
                        }

                        isD = false;
                    }
                }

                if (isS && f !== s[i + count]) {
                    if (end - start < count * 2 - 1) {
                        start = i - count + 1;
                        end = i + count;
                    }

                    isS = false;
                }

                if (!isS && !isD) {
                    break;
                }

                count++;
            }

            if (isD) {
                if (end - start < count * 2) {
                    start = i - count + 1;
                    end = i + count + 1;
                }
            } else {
                if (end - start < count * 2 - 1) {
                    start = i - count + 1;
                    end = i + count;
                }
            }
        }
        
        return s.slice(start, end);
};
```

