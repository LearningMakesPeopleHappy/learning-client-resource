# 31. 下一个排列

## 题目

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

## 思路

### 交换大数排列法

- 从尾部开始查找，直到找到前一个数比当前数小的位置，记录位置为`end_index`，前一个数为`n`。
- 从`end_index`开始向后找到比`n`小的第一个数，将这个数的前一个数与`n`交换。
- 将`end_index`开始往后的元素按照从小到大的顺序排序。（只需要前后交换即可。）

特殊情况：`end_index`为`0`时，不需要置换，只需要将这个数组按照从小到大的顺序排序即可。

#### 时间复杂度

O(n^2^)

#### 空间复杂度

O(1)

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    const len = nums.length;

    let end_index = len - 1;
    while(end_index > 0 && nums[end_index - 1] >= nums[end_index]) {
        end_index--;
    }

    if (end_index === 0) {
        return nums.sort((a, b) => a - b);
    } else {
        const n = nums[end_index - 1];

        let j = end_index;
        while (j < len) {
            if (nums[j] <= n) break;
            j++;
        }

        nums[end_index - 1] = nums[j - 1];
        nums[j - 1] = n;

        const center = Math.floor((len - end_index)/2);
        for (let i = 0;i < center;i++) {
            let current = nums[i + end_index];
            nums[i + end_index] = nums[len - i - 1];
            nums[len - i - 1] = current;
        }
    }

    return nums;
};
```

