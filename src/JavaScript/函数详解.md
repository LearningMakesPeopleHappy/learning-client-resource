# 函数详解

每一个函数都是Function类型的对象，Function可以认为是继承自Object。所以函数名称实际上就是一个指向Function对象的指针。

## 声明

**函数声明语法：**

```javascript
function myfunction(params) {
    // do something ...
}
```

**函数表达式语法：**

```javascript
var myfunction = function(params) {
    // do something ...
};
```

函数表达式这种方法其实是声明了一个匿名函数，并且将这个匿名函数赋值给了一个变量。

以上两种方式均声明了一个函数，其中函数名称不是必须的，可以通过引用的方式调用。

还有一种不推荐的声明方式——**Function构造函数声明法：**

```javascript
var myfunction = new Function("params", "// do something ...");
```

不推荐的原因是因为需要解析两次代码，第一次是正常的JavaScript解析`new Function()`，第二次是传入的字符串`"params"`和`"// do something ..."`，非常影响性能。

一个例子非常清楚的展现函数就是对象：

```javascript
function sum(num1, num2) {
    return num1 + num2;
}

console.log(sum(10, 20)); // 30

var anotherSum = sum;
console.log(anotherSum(20, 20)) // 40

sum = null;
console.log(anotherSum(20, 30)) // 50
```

## 函数声明提升（状态提升）

JavaScript解析器在解析的时候会先读取<u>通过“函数声明”方式声明的函数</u>，并且将<u>通过“函数声明”方式声明的函数</u>提升到所有代码之前，让其在任何代码执行前可用。

至于<u>通过“函数表达式”方式声明的函数</u>则只会在执行到这个语句的时候解析执行。

```javascript
/// 注意下面这段代码仅用于举例

console.log(sum(5, 5)); // 10
console.log(anotherSum(5, 5)); // error

function sum(num1, num2) {
    return num1 + num2;
}

var anotherSum = function(num1, num2) {
    return num1 + num2;
}

console.log(anotherSum(5, 5)); // 10
```

## 作为值

通过“函数表达式”可以创建一个函数，就可以理解函数能够作为一个值（对象）进行传递。所以：

```javascript
function createFunction(params, args) {
    console.log(params);
    return function(args) {
        console.log(args);
    };
}

var newFunction = createFunction(1, 2); // 1

newFunction(2); // 2
```

## arguments

无论函数声明上有多少个参数，函数内部接收到的传入参数个数都是是不确定的，所以内部提供了一个`arguments`的变量。

`arguments`变量是一个类数组的对象，里面存放了按照顺序传入进来的参数。可以通过类似数组的方式获取所有参数`var param = arguments[0];`。

### callee

`arguments`有一个`callee`的属性，这个属性指向arguments所在的函数。

当使用递归函数的时候，为了防止函数名称变化，应该使用这个属性在函数内部调用自身。

> 注意：严格模式下调用`callee`会报错。为了安全，防止第三方代码窥视。

```javascript
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}

console.log(factorial(2)); // 2

var newFactorial = factorial;
console.log(newFactorial(3)); // 6

factorial = null;
console.log(newFactorial(4)); // 24
```

## 函数执行环境

// TODO: 等

## this

`this`引用的是函数执行环境对象。

## caller

`caller`属性指向调用当前函数的函数的引用。

即

```javascript
function outer() {
    inner();
}

function inner() {
    console.log(arguments.callee.caller); // 指向outer函数
}

outer();
```
## 属性

### name

返回函数名称。

不在ECMAScript标准中的属性，但是大部分浏览器都实现了这个属性。

### length

函数期望接收的命名参数的个数。

### prototype

`prototype`是保存引用类型所有实例方法的真正所在。即，`toString()`和`valueOf()`都保存在`prototype`下。

`prototype`不可枚举。

原理：

* 创建一个函数`myFunction()`
* 函数`myFunction()`会自动拥有一个`prototype`属性，这个属性是一个新创建的对象
* 函数`myFunction()`的`prototype`属性里面会新增一个`constructor`属性，这个`constructor`属性又指回了函数`myFunction()`

#### prototype的方法

##### isPrototypeOf(object: Object)

如果一个对象的`[[Prototype]]`指向调用这个`isPrototypeOf()`函数的对象，那么这个函数就返回`true`。

## 方法

### apply()

`apply()`方法接收两个参数：

* 运行函数的作用域；
* 参数数组。可以是数组，也可以是`arguments`对象；

### call()

`call()`方法接收多个参数：

* 运行函数的作用域；
* 其他参数为参数列表。即，将`apply()`方法接收的第二个参数展开；

### bind()

`bind()`方法会创建一个新的函数实例，会将`bind()`方法的参数设置为这个实例的`this`。

### toString()

返回函数代码。

### toLocaleString()

返回函数代码。

### valueOf()

返回函数代码。

## 箭头函数

> 注意：ECMAScript6中定义的新的函数定义语法。

```javascript
let myFunction = (value) => {
    // do something ...
};
```

与传统函数的区别：

* **没有`this`、`super`、`arguments`和`new target`绑定** - 箭头函数中的这些值都和执行环境中的这些值保持一致。
* **不可以通过`new`关键字调用** - 因为箭头函数中没有`[[Construct]]`，所以不可以被用作构造函数。
* **没有原型** - 因为不可以通过`new`关键字调用，所以没有构建原型的需求，所以箭头函数不存在`prototype`这个属性。
* **不可以改变`this`的绑定** - 函数内部的`this`值不可被改变，在函数的生命周期内始终保持一致。
* **不支持重复的命名参数** - 在传统函数中，严格模式下是支持重复的命名参数的。