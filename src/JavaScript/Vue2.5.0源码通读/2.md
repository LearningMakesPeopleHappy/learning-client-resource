# Vue2.5.0源码通读 - 2

`src/platforms/web/entry-runtime.js`中只有简单的两行代码，将我们引导到了`src/platforms/web/runtime/index.js`文件中。

最开始的第一行代码就引入了Vue，让我们追踪它来到`src/core/index.js`文件。

我们发现这还不是Vue的源头，我们接着来到`src/core/instance/index.js`文件。

## 定义Vue实例的方法和属性

`src/core/instance/index.js`文件中我们终于找到了Vue的定义方法：

```javascript
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

这里首先判断了编译环境，之后还判断了是否使用`new`关键字初始化Vue。

判断通过，那么我们就可以初始化一个Vue实例了。

这里可能有小伙伴就要问了，为啥没有`_init`方法？别着急呀，毕竟`new Vue()`是你手动调用的，但是加载完HTML页面之后首先会自动调用下面的几个方法：

```javascript
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

我们一个一个来看。

### initMixin

我们打开`src/core/instance/init.js`。

你看，`_init`方法是不是找到了，`initMixin`中定义了Vue实例的`_init`方法。

### stateMixin

打开`src/core/instance/state.js`文件。

`stateMixin`中定义了Vue实例的`$data`和`$props`，这两个都是访问器属性。`$data`是获取当前Vue实例的`_data`的值，设置`$data`则是输出警告而不做任何事情。`$props`是输出前Vue实例的`_props`的值，设置`$props`则是输出警告而不做任何事情。意思就是将`$data`和`$props`设置为一个只读的动态属性。

`stateMixin`中还定义了Vue实例的`$set`和`$delete`方法。这两个方法都在`src/core/observer/index.js`中定义了。这个`$set`就是我们经常用的给一个对象添加新的属性、或给数组添加新的元素（修改旧元素）时使用的方法了。`$delete`则是删除对象中的属性、或删除数组中的元素时用到的。

`stateMixin`中最后定义了Vue实例的`$watch`方法。

###eventsMixin

打开`src/core/instance/events.js`文件。

`eventsMixin`中定义了Vue实例的`$on`、`$once`、`$off`和`$emit`。这四个就是我们通常多创建一个Vue实例用语处理全局时间监听的方法。

### lifecycleMixin

打开`src/core/instance/lifecycle.js`文件。

`lifecycleMixin`中定义了Vue实例的`_update`、`$forceUpdate`和`$destroy`方法。

### renderMixin

打开`src/core/instance/render.js`文件。

`renderMixin`中定义了Vue实例的`$nextTick`和`_render`方法。



## 定义Vue函数对象的方法和类属性

看完对Vue实例的方法定义，我们回到`src/code/index.js`文件中。

除去导入部分，第一行代码`initGlobalAPI(Vue)`就对调用Vue函数做了一些处理（你也可以理解为对Vue这个类做了一些处理）。

首先给Vue函数对象定义了一个名为`config`的访问器属性，并且将这个`config`设置为只读的动态属性。

```javascript
// config
const configDef = {}
configDef.get = () => config
if (process.env.NODE_ENV !== 'production') {
    configDef.set = () => {
        warn(
        	'Do not replace the Vue.config object, set individual fields instead.'
        )
    }
}
Object.defineProperty(Vue, 'config', configDef)
```

`config`属性是一个对象：

* **optionMergeStrategies** - 选项合并策略（用于`core`/`util`/`options`）。初始值为空对象。
* **silent** - 是否取消警告。初始值为`false`。
* **productionTip** - 是否在启动时显示生产模式提示消息。初始值取决于运行环境。
* **performance** - 是否记录性能。初始值为`false`。
* **devtools** - 是否启用devtools。初始值取决于运行环境。
* **errorHandler** - 观察者发生错误时的错误处理。初始值为`null`。
* **warnHandler** - 观察者产生警告时的警告处理。初始值为`null`。
* **ignoredElements** - 要忽略的自定义元素列表。初始值为空数组。
* **keyCodes** - v-on的用户自定义键名。初始值为空对象。
* **isReservedTag** - 检查标签是否是保留标签，保留标签不能注册为组件。这与平台有关，可能会被覆盖。初始值是一个默认返回`false`的函数。
* **isReservedAttr** - 检查属性是否是保留属性，保留属性不能用作组件属性。这与平台有关，可能会被覆盖。初始值是一个默认返回`false`的函数。
* **parsePlatformTagName** - 解析特定平台的真实标签名称。初始值是一个返回输入值的函数。
* **isUnknownElement** - 检查标签是否为未知元素。依赖平台。
* **getTagNamespace** - 获取元素的命名空间。初始值是一个空函数。
* **mustUseProp** - 检查是否必须使用property来绑定attribute，例如`value`。初始值是一个默认返回`false`的函数。
* **_lifecycleHooks** - 由于遗留原因而暴露。生命周期名称数组。

> **注意：**`config`属性是一个不可更改的属性，但是`config`属性返回的对象的内容是可以更改的。

之后给Vue函数对象定义了一个名为`util`属性，这个属性是一些公开的工具方法，

```javascript
// 公开的公共方法。
// 注意：这些方法不被视为公共API的一部分-除非你了解使用它们的风险，否则应避免使用它们。
Vue.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
}
```

* **warn(msg: string, vm?: Component)** - 输出警告。
* **extend(to: Object, _from?: Object)** - 传入两个对象，将第二对象的属性合并到第一个对象中（注意：会覆盖第一个对象中的现有属性）。
* **mergeOptions(parent: Object, child: Object, vm?: Component)** - 将两个选项对象合并到一个新的对象中。在Vue的实例化和继承中都会使用到的核心方法。
* **defineReactive(obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean)** - 在对象上定义响应式属性。

接着，为Vue函数对象设置了`set`、`delete`、`nextTick`方法。除了`nextTick`有所不同外，`set`和`delete`与Vue实例中的`set`和`delete`一样。

之后为Vue函数对象设置了一个`options`对象：

* **components**
    * **KeepAlive** - VNode对象。
* **directives** - 暂时为空对象。
* **filters** - 暂时为空对象。
* **_base** - Vue函数对象本身。

通过`initUse`方法为Vue函数对象设置了一个`use`方法。

通过`initMixin`方法为Vue函数对象设置了一个`mixin`方法。

通过`initExtend`方法为Vue函数对象设置了一个`cid`属性和一个`extend`方法。

通过`initAssetRegisters`方法为Vue函数对象设置了`component`、`directive`和`filter`方法。

## 定义Vue实例的附加方法

`src/code/index.js`文件的`initGlobalAPI(Vue)`之后，为Vue实例设置了只读属性`$isServer`和`$ssrContext`。

## 定义其他的Vue类属性

`src/code/index.js`文件的最后为Vue方法对象设置了`version`属性。

## 定义Web中Vue的属性和方法

`src/code/index.js`文件处理完毕我们回到`src/platforms/web/runtime/index.js`文件中。

首先设置了Vue函数对象的`config`属性里面的一些常用方法：`mustUseProp`、`isReservedTag`、`isReservedAttr `、`getTagNamespace`、`isUnknownElement`。

接着设置了Vue函数对象的`options`属性里面的`directives`和`components`。

然后对Vue的实例增加了`__patch__`方法、`$mount`方法。

最后调用Vue函数对象的`nextTick`方法增加了一个回调函数，用于对`devtools`做处理。

## 图解Vue属性和方法

最后我们通过几张图来总结一下Vue函数对象和Vue实例上具体都有哪些方法和属性。













通过`$set`的源码我们能够看到如果是对数组进行操作，其实就是执行了`splice`函数。

```javascript
if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
}
```

对于非数组的对象（或者数组中的属性）则会先查询对象中是否存在这个响应式的属性，如果存在就直接更改值，如果不存在那么就去设置。

```javascript
if (hasOwn(target, key)) { // 查询对象中是否存在该属性。
    target[key] = val
    return val
}
// __ob__是区分组建中data数据还是非data数据的。
const ob = (target: any).__ob__
// 这里判断了一下是否是Vue实例。
if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
	)
	return val
}
if (!ob) { // 不是需要响应的数据，直接赋值。
    target[key] = val
    return val
}
defineReactive(ob.value, key, val) // 设置响应式属性
ob.dep.notify() // 发通知呀
return val
```

设置时调用了`defineReactive`这个方法。

```javascript
export function defineReactive (
  obj: Object, // 要设置新属性的对象
  key: string, // 新属性的名称
  val: any, // 新属性的值
  customSetter?: ?Function, // 自定义setter
  shallow?: boolean // 是否是浅层响应
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key) // 检查一下属性的描述符
  if (property && property.configurable === false) {
    // 如果是不可修改的属性那么就不设置。
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get // 如果之前有定义过属性的getter方法就获取一下
  const setter = property && property.set // 如果之前有定义过属性的setter方法就获取一下

  let childOb = !shallow && observe(val) // 不是浅层响应，并且值是对象就获取一个值的观察者。注意，只有对象才有观察者。
  Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: true, // 可修改
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val // 如果之前有定义过属性的getter方法就先调用一下。
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val // 如果之前有定义过属性的getter方法就先调用一下，获取到旧的值。
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) { // 新旧值相等则不处理
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter() // 调用自定义setter
      }
      if (setter) { // 如果之前有定义过属性的setter方法就调用一下。
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal) // 不是浅层响应，并且新值是对象，就拿到它的观察者。
      dep.notify()
    }
  })
}
```



通过前面的`import`我们能够了解到`src/platforms/web/util/index.js`中保存了一些配置信息。

首先是`mustUseProp`，在`src/platforms/web/util/attrs.js`里面能够找到这个函数。

`isReservedTag`在`src/platforms/web/util/element.js`里面能够找到这个函数，这个函数主要判断输入的字符串是否是HTML标签名称或SVG标签名称的。

`isReservedAttr`在`src/platforms/web/util/attrs.js`里面能够找到这个函数，这个函数主要判断输入的字符串是不是`style`或`class`，处理CSS用的。

`getTagNamespace`在`src/platforms/web/util/element.js`里面能够找到这个函数，输入的字符是SVG标签名称就返回`svg`输入的是`math`就返回`math`，其他的都返回`undefined`。

`isUnknownElement`在`src/platforms/web/util/element.js`里面能够找到这个函数，主要用于判断输入的字符串是不是有效的HTML/SVG元素。

