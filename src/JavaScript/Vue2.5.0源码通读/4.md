# Vue2.5.0源码通读 - 4

## 渲染

承接上文：

```javascript
if (vm.$options.el) {
    vm.$mount(vm.$options.el)
}
```

我们要去调用`$mount`方法。在之前整理的过程中，我们能够找到`$mount`方法位于`src/platforms/web/runtime/index.js`文件中。

### `$mount`函数

```javascript
Vue.prototype.$mount = function (
  el?: string | Element, // #app
  hydrating?: boolean // undefined
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

首先调用`query()`函数查找对应的DOM。

如果是字符串，那么就去document中查找，找到直接返回，找不到就创建一个不在document中的div返回。

如果不是字符串，那么就已经是DOM了，直接返回即可。

接下来调用`mountComponent`函数。

### `mountComponent`函数

`mountComponent`函数位于`src/core/instance/lifecycle.js`中：

```javascript
function mountComponent (
  vm: Component,
  el: ?Element, // <div id="app"></div>
  hydrating?: boolean // undefined
): Component {
  vm.$el = el
  if (!vm.$options.render) { // undefined
    vm.$options.render = createEmptyVNode // 设置默认的渲染函数
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  callHook(vm, 'beforeMount') // 调用beforeMount生命周期函数

  let updateComponent
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) { // 跳过
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating) // src/core/instance/lifecycle.js - lifecycleMixin
    }
  }

  vm._watcher = new Watcher(vm, updateComponent, noop)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

上面的代码中我们能够看到，因为在`options`中并没有设置`render`函数，所以首先给定了一个默认的`render`函数：`createEmptyVNode`。

然后下面设定了一个`updateComponent`函数。

紧接着使用这个`updateComponent`函数设置了一个`Watcher`，

因为`vm.$vnode`是`undefined`使用两个等号和`null`对比时会进行类型转换，这两个相等，所以为当前的Vue实例设置一个`_isMounted`属性，值为`true`，表示渲染完毕。

调用`mounted`生命周期函数。

到此为止，整个Vue实例的初始化就算完毕了。

最后有人会问了，也没尽兴渲染呀，别着急，我们在上面不是创建了一个`Watcher`嘛，回过头来看这里。



我们先来看`Watcher`的构造函数：

```javascript
constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: Object
  ) {
    this.vm = vm
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }
```

上面的所有代码只是进行基本的设置，我们看最下面，先判断`this.lazy`，因为我们是初始化，必然不可能是懒加载，所以直接调用`this.get()`。

```javascript
get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
}
```

`pushTarget`先不去管，这个是对`Dep.target`的设置。

我们直接看`try`里面的这一行，直接以`vm`为`this`调用了`getter`函数，这个`getter`函数是什么呢？就是之前定义的：

```javascript
updateComponent = () => {
    vm._update(vm._render(), hydrating) // src/core/instance/lifecycle.js - lifecycleMixin
}
```

相当于先调用了`_render`函数之后调用了`_update`函数，我们一个一个来看：

这是`_render`函数，即`src/core/instance/render.js`的`createEmptyVNode`函数：

```javascript
Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (vm._isMounted) { // false
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (const key in vm.$slots) {
        const slot = vm.$slots[key]
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */)
        }
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject // Object.freeze({})

    // 设置父vnode。这使渲染功能可以访问占位节点上的数据。
    vm.$vnode = _parentVnode // undefined
    // 渲染自身
    let vnode
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement) // createEmptyVNode
    } catch (e) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
          } catch (e) {
            handleError(e, vm, `renderError`)
            vnode = vm._vnode
          }
        } else {
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode // undefined
    return vnode
  }
```

将`createEmptyVNode`函数创建的空VNode传入`_update`函数中：

```javascript
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    if (vm._isMounted) { // false
      callHook(vm, 'beforeUpdate')
    }
    const prevEl = vm.$el // <div id="app">...</div>
    const prevVnode = vm._vnode // null
    const prevActiveInstance = activeInstance // null
    activeInstance = vm
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) { // null
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      )
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    activeInstance = prevActiveInstance
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }
```

上面代码中，当判断`prevVnode`为空后，调用了`vm.__patch__`函数，这个函数是在`src/core/vdom/patch.js`中定义的`patch`方法。

调用时传入了以下参数：

* `oldVnode` =` vm.$el` = `<div id="app">...</div>`
* `vnode` = `vnode` = 空`Vnode`实例
* `hydrating` = `false`
* `removeOnly` = `undefined`
* `refElm` = `undefined`

```javascript
function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) { // 判断vnode是否为undefined或null
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) { // 判断oldVnode是否为undefined或null
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue, parentElm, refElm)
    } else {
      const isRealElement = isDef(oldVnode.nodeType) // isRealElement = true
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) { // true && false
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) { // false
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              )
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          // 根据真实节点创建一个虚拟节点
          oldVnode = emptyNodeAt(oldVnode) // oldVnode = new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, oldVnode)
        }
        // replacing existing element
        const oldElm = oldVnode.elm // oldElm = <div id="app">...</div>
        const parentElm = nodeOps.parentNode(oldElm) // 获取父节点，这里是parentElm = body
        createElm(
          vnode, // 空VNode实例
          insertedVnodeQueue, // []
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm, // body
          nodeOps.nextSibling(oldElm)
        )

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
}
```

