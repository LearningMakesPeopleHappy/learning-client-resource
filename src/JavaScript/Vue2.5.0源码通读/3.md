# Vue2.5.0源码通读 - 3

## 初始化

我们以官方教程中创建的默认代码为开始：

HTML：

```html
<div id="app">
  <p>{{ foo }}</p>
  <button v-on:click="buttonClickEvent">Change it</button>
</div>
```

JavaScript：

```javascript
new Vue({
    el: '#app',
    data: {
        foo: 'bar'
    },
    created: function () {
        console.log('foo is: ' + this.foo)
    },
    methods: {
        buttonClickEvent: function () {
            this.foo = "foo"
        }
    }
})
```



### 构造函数

`src/core/instance/index.js`文件中，我们开始进行对Vue的初始化，这里是Vue的构造函数所在。

```javascript
function Vue (options) {
    /* 打包中下面这句话会被忽略，原因是rollup-plugin-replace会识别process.env.NODE_ENV，从而区分开发环境和生产环境 */
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

这里首先调用了`_init`方法，这个方法是在`src/core/instance/init.js`中。

传入的`options`是：

```javascript
{
    el: '#app',
    data: {
        foo: 'bar'
    },
    created: function () {
        console.log('foo is: ' + this.foo)
    },
    methods: {
        buttonClickEvent: function () {
            this.foo = "foo"
        }
    }
}
```

函数中从获取一下当前`this`指向：

```javascript
const vm: Component = this
```

设置`uid`属性：

```javascript
vm._uid = uid++ // 因为这里是第一次创建，所以 _uid 为 0
```

开始和结束两个变量：

```javascript
let startTag, endTag
```

下面这段代码会被忽略，原因是`rollup`打包插件`rollup-plugin-replace`会识别`process.env.NODE_ENV`，从而区分开发环境和生产环境。（之后类似的生产环境中无用的代码都不再展示）

```javascript
if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    startTag = `vue-perf-start:${vm._uid}`
    endTag = `vue-perf-end:${vm._uid}`
    mark(startTag)
}
```

设置一个标志，表示当前这个实例是Vue实例，之后观察者会根据这个标示决定是否要观察：带有这个标志的就不会被观察。

```javascript
vm._isVue = true
```

下面会去判断是组件初始化还是Vue实例初始化，这里我们只看Vue实例的初始化：

```javascript
vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor), // Vue函数对象上的options
    options || {}, // 初始化传进来的options
    vm // 当前Vue实例
)
```

这里面先调用写在下面的`resolveConstructorOptions`方法获取了一下Vue函数对象上的默认选项：

```javascript
export function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options // Vue.prototype.options
  if (Ctor.super) { // 对于非继承来说，这里是undefined，所以跳过
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}
```

上面的`resolveConstructorOptions`方法返回了Vue函数对象中的`options`，具体的这个返回的`options`里面包含什么，可以参考上一篇文章末尾的图。

然后调用`mergeOptions`将Vue函数对象上的默认选项和初始化Vue实例时传入的选项合并到当前的Vue实例中。

#### `mergeOptions`函数

`mergeOptions`函数在`src/core/util/options.js`文件中。

```javascript
function mergeOptions (
    parent: Object, // Vue.prototype.options
    child: Object, // Vue构造函数传入的选项
    vm?: Component // 当前Vue实例
): Object {
    ...
}
```

##### `normalizeProps`函数

首先处理`props`：

```javascript
normalizeProps(child, vm)
```

将`props`对象化，即：如果`props`是数组，那么遍历元素`val`，元素`val`如果是字符串，那么就将元素`val`设置为`props`的key，值为`null`。如果`props`是对象（多重继承的也算），那么就遍历key，值如果是对象就保持不变，如果是函数，就设置为类型。

```javascript
function normalizeProps (options: Object, vm: ?Component) {
  const props = options.props // undefined
  if (!props) return // 直接return
  const res = {}
  let i, val, name
  if (Array.isArray(props)) { // 是数组
    i = props.length
    while (i--) {
      val = props[i]
      if (typeof val === 'string') { // 只有数组元素是字符串时才会设置进props
        name = camelize(val)
        res[name] = { type: null }
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.')
      }
    }
  } else if (isPlainObject(props)) { // 是对象
    for (const key in props) {
      val = props[key]
      name = camelize(key)
      res[name] = isPlainObject(val) // 值如果是对象就保持不变，否则（是函数）就将值设置为类型。
        ? val
        : { type: val }
    }
  } else if (process.env.NODE_ENV !== 'production' && props) { // 其他的放弃
    warn(
      `Invalid value for option "props": expected an Array or an Object, ` +
      `but got ${toRawType(props)}.`,
      vm
    )
  }
  options.props = res
}
```

但是因为我们的例子中并没有`props`属性，所以这里不做详细说明。

##### `normalizeInject`函数

接着处理`inject`：

```javascript
normalizeInject(child, vm)
```

同`props`的处理方式类似：

1. 先判断是否是数组，如果是数组，就把每个元素`val`既设置为`key`又设置为值。
2. 之后判断是否是对象，是对象的话，遍历对象`key`和`val`，`key`不变，判断`val`是否是对象：
    1. `val`是对象的话就在值中添加一个`from`属性，`from`属性的值是`key`，
    2. 如果`val`不是对象的话，就把`key`对应的值设置为`{ from: val }`

```javascript
function normalizeInject (options: Object, vm: ?Component) {
  const inject = options.inject // undefined
  const normalized = options.inject = {}
  if (Array.isArray(inject)) { // 数组，跳过
    for (let i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] }
    }
  } else if (isPlainObject(inject)) { // 对象，跳过
    for (const key in inject) {
      const val = inject[key]
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val }
    }
  } else if (process.env.NODE_ENV !== 'production' && inject) { // 跳过
    warn(
      `Invalid value for option "inject": expected an Array or an Object, ` +
      `but got ${toRawType(inject)}.`,
      vm
    )
  }
}
```

但是因为我们的例子中并没有`inject`属性，所以这里只会给`options`中设置一个key为`inject`，值为`{}`的属性。

##### `normalizeDirectives`函数

然后处理`directives`：

```javascript
normalizeDirectives(child)
```

遍历处理`directives`，如果设置的指令的`val`为函数，则会转为`{ bind: def, update: def }`结构，`def`为指令原始函数值。即将设置的指令原始函数指向指令的`bind`和`update`钩子函数。

```javascript
function normalizeDirectives (options: Object) {
  const dirs = options.directives // undefined
  if (dirs) { // 跳过
    for (const key in dirs) {
      const def = dirs[key]
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def }
      }
    }
  }
}
```

哈，因为`options`中也没有`directives`属性，所以这里并没有做任何的处理。

##### 最后

处理`extends`，即递归调用`mergeOptions`函数处理传入的`parent`和`child.extends`：

```javascript
const extendsFrom = child.extends // undefined
if (extendsFrom) { // 跳过
    parent = mergeOptions(parent, extendsFrom, vm)
}
```

因为例子并没有继承关系，所以这里依然是跳过处理。

之后，如果`child`中有`mixins`，那么遍历`child.mixins`，并递归调用`mergeOptions`函数处理传入的`parent`和`child.mixins[i]`：

```javascript
if (child.mixins) { // undefined，跳过
    for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
    }
}
```

`options`也没有`mixins`，跳过。

遍历处理`parent`，得到`key`，根据不同的`key`选择不同的`strat`函数：

```javascript
const options = {}
let key
for (key in parent) { // components, directives, filters, _base
    mergeField(key)
}
for (key in child) {
    if (!hasOwn(parent, key)) { // el, data, created, methods, inject
    	mergeField(key)
    }
}
function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
}
```

以下是不同的`key`对应的各自的`strat`函数：

* `components`，`directives`，`filters`使用`mergeAssets`函数。

    ```javascript
    function mergeAssets (
      parentVal: ?Object,
      childVal: ?Object,
      vm?: Component,
      key: string
    ): Object {
      const res = Object.create(parentVal || null) // parentVal作为__proto__创建一个“空对象”。
      if (childVal) { // undefined
        process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm)
        return extend(res, childVal)
      } else {
        return res
      }
    }
    ```

* `_base`，`el`使用默认的`defaultStrat`。

    ```javascript
    const defaultStrat = function (parentVal: any, childVal: any): any {
      return childVal === undefined
        ? parentVal
        : childVal
    }
    ```

* `data`使用单独的自己的处理函数。

    ```javascript
    function (
      parentVal: any,
      childVal: any,
      vm?: Component
    ): ?Function {
      if (!vm) { // vm不为空，跳过
        if (childVal && typeof childVal !== 'function') {
          process.env.NODE_ENV !== 'production' && warn(
            'The "data" option should be a function ' +
            'that returns a per-instance value in component ' +
            'definitions.',
            vm
          )
    
          return parentVal
        }
        return mergeDataOrFn.call(this, parentVal, childVal)
      }
    
      return mergeDataOrFn(parentVal, childVal, vm) // 返回一个merge函数。
    }
    ```

* `created`等生命周期函数使用`mergeHook`函数

    ```javascript
    function mergeHook (
      parentVal: ?Array<Function>,
      childVal: ?Function | ?Array<Function>
    ): ?Array<Function> {
      return childVal // 有
        ? parentVal // undefined
          ? parentVal.concat(childVal)
          : Array.isArray(childVal) // 不是
            ? childVal
            : [childVal] // 返回这个
        : parentVal
    }
    ```

* `props`，`methods`，`inject`，`computed`使用同一个处理函数

    ```javascript
    function (
      parentVal: ?Object,
      childVal: ?Object,
      vm?: Component,
      key: string
    ): ?Object {
      if (childVal && process.env.NODE_ENV !== 'production') { // 跳过
        assertObjectType(key, childVal, vm)
      }
      if (!parentVal) return childVal // 直接返回childVal
      const ret = Object.create(null)
      extend(ret, parentVal)
      if (childVal) extend(ret, childVal)
      return ret
    }
    ```

* `provide`使用`mergeDataOrFn`函数

    ```javascript
    function mergeDataOrFn (
      parentVal: any,
      childVal: any,
      vm?: Component
    ): ?Function {
      if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
          return parentVal
        }
        if (!parentVal) {
          return childVal
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn () {
          return mergeData(
            typeof childVal === 'function' ? childVal.call(this) : childVal,
            typeof parentVal === 'function' ? parentVal.call(this) : parentVal
          )
        }
      } else if (parentVal || childVal) {
        return function mergedInstanceDataFn () {
          // instance merge
          const instanceData = typeof childVal === 'function'
            ? childVal.call(vm)
            : childVal
          const defaultData = typeof parentVal === 'function'
            ? parentVal.call(vm)
            : parentVal
          if (instanceData) {
            return mergeData(instanceData, defaultData)
          } else {
            return defaultData
          }
        }
      }
    }
    ```

* `watch`使用自己的处理函数

    ```javascript
    function (
      parentVal: ?Object,
      childVal: ?Object,
      vm?: Component,
      key: string
    ): ?Object {
      // work around Firefox's Object.prototype.watch...
      if (parentVal === nativeWatch) parentVal = undefined
      if (childVal === nativeWatch) childVal = undefined
      /* istanbul ignore if */
      if (!childVal) return Object.create(parentVal || null)
      if (process.env.NODE_ENV !== 'production') {
        assertObjectType(key, childVal, vm)
      }
      if (!parentVal) return childVal
      const ret = {}
      extend(ret, parentVal)
      for (const key in childVal) {
        let parent = ret[key]
        const child = childVal[key]
        if (parent && !Array.isArray(parent)) {
          parent = [parent]
        }
        ret[key] = parent
          ? parent.concat(child)
          : Array.isArray(child) ? child : [child]
      }
      return ret
    }
    ```

最后返回`options`。本例中，最后返回的`options`（也就是`Vue.$options`）中会包含以下内容：

* **components** - "空对象"，但是`__proto__`中含有默认组件。
    * KeepAlive
    * Transition
    * TransitionGroup
* **directives** -  "空对象"，但是`__proto__`中含有默认指令。
    * model
    * show
* **filters** - 空对象，`__proto__`也是一个空对象。
* **_base** - Vue构造函数。
* **el** - 构造函数参数重传入的字符串：`"#app"`。
* **data** - 一个`mergedInstanceDataFn`函数。
* **created** - 一个数组，里面的唯一元素是构造函数中传入的对应的生命周期函数。
* **methods** - 构造函数中传入的自定义方法列表
    * buttonClickEvent - 函数。
* **inject** - 空对象

#### `mergeOptions`函数处理完毕

到此，`mergeOptions`函数处理完毕。回到`_init`函数中来。

设置一个标志：

```javascript
vm._renderProxy = vm
```

设置一个自我标示：

```javascript
vm._self = vm
```

调用`initLifecycle`函数处理：

#### `initLifecycle`函数

```javascript
function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent // undefined
  if (parent && !options.abstract) { // 跳过
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent // undefined
  vm.$root = parent ? parent.$root : vm // vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```

接着调用过`initEvents`函数：

#### `initEvents`函数

```javascript
function initEvents (vm: Component) {
  vm._events = Object.create(null) // null
  vm._hasHookEvent = false
  // init parent attached events
  const listeners = vm.$options._parentListeners // undefined
  if (listeners) { // 跳过
    updateComponentListeners(vm, listeners)
  }
}
```

然后调用`initRender`函数：

#### `initRender`函数

```javascript
export function initRender (vm: Component) {
  vm._vnode = null // 当前虚拟dom树的根结点
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode // 父树中的占位节点，undefined
  const renderContext = parentVnode && parentVnode.context // undefined
  vm.$slots = resolveSlots(options._renderChildren, renderContext) // 两个参数都是空对象，所以这里返回一个空对象{}
  vm.$scopedSlots = emptyObject // Object.freeze({})，也就是不可更改对象。
  // 将createElement绑定到当前实例上，以便我们在函数中获取适当的渲染上下文
  // 参数顺序：tag, data, children, normalizationType, alwaysNormalize
  // 内部使用的版本，从模板编译的渲染函数。
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // 应用于用户编写的渲染函数中使用的公共版本。
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

  // 公开$attrs和$listeners可以更轻松地创建HOC。
  // 他们需要做出反应，以便始终更新使用它们的HOC。
  const parentData = parentVnode && parentVnode.data // undefined

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') { // 忽略
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm)
    }, true)
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
      !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm)
    }, true)
  } else { // 这里要执行
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true) // 设置vm.$attrs为响应式属性，值为Object.freeze({})
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true) // 设置vm.$listeners为响应式属性，值为Object.freeze({})
  }
}
```

#### 调用`beforeCreate`生命周期函数

```javascript
callHook(vm, 'beforeCreate')
```

#### `initInjections`函数

在处理`data`和`props`之前解决`injections`问题。

```javascript
export function initInjections (vm: Component) {
  const result = resolveInject(vm.$options.inject, vm) // null
  if (result) {
    observerState.shouldConvert = false
    Object.keys(result).forEach(key => {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], () => {
          warn(
            `Avoid mutating an injected value directly since the changes will be ` +
            `overwritten whenever the provided component re-renders. ` +
            `injection being mutated: "${key}"`,
            vm
          )
        })
      } else {
        defineReactive(vm, key, result[key])
      }
    })
    observerState.shouldConvert = true
  }
}
```

因为`vm.$options.inject`是空对象`{}`，所以`resolveInject()`函数处理之后返回一个`null`，接着下面的`if`内就不会继续执行了。

#### `initState`函数

```javascript
function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props) // undefined
  if (opts.methods) initMethods(vm, opts.methods) // 有值
  if (opts.data) { // 有值
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed) // undefined
  if (opts.watch && opts.watch !== nativeWatch) { // undefined
    initWatch(vm, opts.watch)
  }
}
```

如果有`props`，就先处理`props`：

##### `initProps`函数

因为在本例中的`options`并没有`props`属性，所以先跳过。

```javascript
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  observerState.shouldConvert = isRoot
  for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      defineReactive(props, key, value, () => {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  observerState.shouldConvert = true
}
```

接着，如果有`methods`就去处理`methods`：

#####`initMethods`函数 

```javascript
function initMethods (vm: Component, methods: Object) {
    const props = vm.$options.props // undefined
    for (const key in methods) {
        if (process.env.NODE_ENV !== 'production') { // 跳过
            if (methods[key] == null) {
                warn(
                    `Method "${key}" has an undefined value in the component definition. ` +
                    `Did you reference the function correctly?`,
                    vm
                )
            }
            if (props && hasOwn(props, key)) {
                warn(
                    `Method "${key}" has already been defined as a prop.`,
                    vm
                )
            }
            if ((key in vm) && isReserved(key)) {
                warn(
                    `Method "${key}" conflicts with an existing Vue instance method. ` +
                    `Avoid defining component methods that start with _ or $.`
                )
            }
        }
        // 如果函数为null则设置为空函数，否则就将当前Vue实例绑定在函数上。
        // 这里的绑定实际上是在外层包装了一层函数后里面通过apply或call掉用原本的函数。
        vm[key] = methods[key] == null ? noop : bind(methods[key], vm)
    }
}
```

如果`options`中有`data`，那么就去处理`data`：

##### `initData`函数

```javascript
function initData (vm: Component) {
  let data = vm.$options.data // { foo: "bar" }
  data = vm._data = typeof data === 'function' // 这里会判断是否是函数返回的data，如果是的话就以当前Vue实例作为this调用函数获得返回的函数。
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) { // 如果data不是一个对象，那么就设置成为一个空对象。
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data) // 获取data中的所有key，["foo"]
  const props = vm.$options.props // undefined
  const methods = vm.$options.methods // { buttonClickEvent: function(){} }
  let i = keys.length // 1
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') { // 跳过
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) { // 跳过
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) { // 如果字符串是以 $ 或 _ 开头的，那么就走下面的处理。因为本例中没有这样的情况，所以我们跳过
      proxy(vm, `_data`, key)
    }
  }
  // 设置观察data
  observe(data, true /* 这个参数用于告知是根data */)
}
```

接着判断`options`中是否有`computed`，有的话就去处理：

##### `initComputed`函数

```javascript
function initComputed (vm: Component, computed: Object) {
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}
```

最后处理`options`中的`watch`：

##### `initWatch`函数

```javascript
function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}
```

`initState`函数执行完毕后执行`initProvide`函数

#### `initProvide`函数

```javascript
function initProvide (vm: Component) {
  const provide = vm.$options.provide // undefined
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide
  }
}
```

这里我们初始化时并没有设置`provide`，所以跳过。

到现在为止，我们可以说是基本完成Vue的初始化了。

#### 调用`created`生命周期函数

```javascript
callHook(vm, 'created')
```

最后我们开始渲染部分

```javascript
if (vm.$options.el) {
    vm.$mount(vm.$options.el)
}
```





